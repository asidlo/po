# Design Choice For Po

I could have gone with a more oop design for Po by utilizing a setup similar to the one presented in interfaces.go. This would allow us to store more meta information about the dataframe in the dataframe struct, as well as iterate through the series and preserve the type via assertions. However, this comes with the ease of use tradeoff as I would need to create helper functions to replace the syntax used to access, index, and manage the native slice and map constructs. That syntax is one of the key reasons why Go can be so similar to Python in appearance since you can perform slices on arrays in python and map accessors via bracket notation. It is for this reason that I have chosen to persue using the native constructs instead of user defined structs to represent dataframes and series.